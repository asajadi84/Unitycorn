---
id: unityscripting_unityclasses
title: کلاس‌های پراستفاده‌ی یونیتی
slug: /unityscripting/unityclasses
---

موتور بازی‌سازی یونیتی دارای کلاس‌هایی است که به صورت اختصاصی برای آن نوشته شده و در فضای نام `UnityEngine` قرار دارند. این فضای نام به طور پیش‌فرض به تمام اسکریپت‌هایی که در ادیتور یونیتی ساخته می‌شوند به واسطه‌ی قطعه کد `using UnityEngine` (که در ابتدای اسکریپت نوشته می‌شود) وارد می‌گردد.

کلاس‌هایی که در این فضای نام قرار دارند امکان پیاده‌سازی هر آن چه که در ذهن طراح بازی می‌گذرد را در قالب کد فراهم می‌کنند. بنابراین یک اسکریپت‌نویسی یونیتی علاوه بر دانستن اصول ابتدایی زبان سی شارپ باید با کلاس‌های پراستفاده و کاربردی یونیتی نیز آشنایی نسبی داشته باشد. به همین منظور در این بخش به بررسی تعدادی از کلاس‌های فوق و اجزای مهم‌شان می‌پردازیم.

بدیهی است که امکان بررسی تک تک این کلاس‌ها در اینجا وجود ندارد. در صورت نیاز به مشاهده‌ی تمام کلاس‌های یونیتی و بررسی اجزای آن‌ها به تفضیل به «اسکریپت رفرنس یونیتی» به آدرس https://docs.unity3d.com/ScriptReference مراجعه نمایید.

در این بخش به منظور بررسی کلاس‌های فضای نام `UnityEngine`، آن‌ها را به چهار دسته‌ی اصلی تقسیم کرده‌ایم:

* کلاس‌های نگهدارنده‌ی مختصات
* کلاس‌های اطلاع‌رسانی و محاسبه
* کلاس `GameObject`
* کلاس‌های کامپوننت‌ها

## کلاس‌های نگهدارنده‌ی مختصات

کلاس‌های نگهدارنده‌ی مختصات کلاس‌هایی هستند که با ساخت شی از روی آن‌ها می‌توان مختصات یک نقطه (بردار) را در آن شی ذخیره کرد. این کلاس‌ها اغلب برای ذخیره‌ی موقعیت مکانی گیم آبجکت‌ها و محاسبات برداری مورد استفاده قرار گرفته و به همین دلیل کاربرد فراوانی در اسکریپت‌نویسی یونیتی دارند.

دو کلاس اصلی این دسته `Vector2` و `Vector3` بوده که از `Vector2` برای ذخیره‌ی مختصات دوبعدی (بردار دوبعدی) و از `Vector3` برای ذخیره‌ی مختصات سه‌بعدی (بردار سه‌بعدی) استفاده می‌شود.

این کلاس‌ها معمولاً به عنوان فیلد تعریف شده و سپس توسط کد مقداردهی شده و در متدها عملیات موردنظر بر روی آن‌ها انجام می‌شود. ضمن آن که این نوع داده‌ها امکان سریالایز شدن و مقداردهی ثانویه در Inspector را نیز دارا می‌باشند.

### `Vector2`

`Vector2` نوع داده‌ای است که امکان ذخیره‌ی مختصات دوبعدی را دارد. این نوع داده در واقع از دو پراپرتی float تشکیل شده که `x` طول نقطه‌ی مختصات و `y` عرض نقطه‌ی مختصات را در خود ذخیره می‌کند. این دو پراپرتی توسط متد سازنده مقداردهی می‌شوند؛ به عنوان مثال:

![image](/img/unity_vector2_class.png)

:::note نکته
امکان دسترسی (خواندن/نوشتن) به پراپرتی‌های `x` و `y` از طریق dot operator نیز وجود دارد.
:::

اعضای مهم این کلاس عبارتند از:

* پراپرتی‌های استاتیک (این پراپرتی‌ها نیازی به وجود یک شی از نوع کلاس نداشته و استفاده از آن‌ها با نوشتن کلمه‌ی کلیدی `Vector2`، عملگر نقطه و نام پراپرتی امکان‌پذیر است):

![image](/img/unity_vector2_class_static_properties.png)

* پراپرتی‌ها (این پراپرتی‌ها تنها در صورت وجود یک شی معنی پیدا می‌کنند و استفاده از آن‌ها با نوشتن نام شی، عملگر نقطه و نام پراپرتی امکان‌پذیر است):

![image](/img/unity_vector2_class_properties.png)

* متدهای استاتیک (این متدها نیازی به وجود یک شی از نوع کلاس نداشته و استفاده از آن‌ها با نوشتن کلمه‌ی کلیدی `Vector2`، عملگر نقطه و نام متد امکان‌پذیر است):

![image](/img/unity_vector2_class_static_methods.png)

* متدها (این متدها تنها در صورت وجود یک شی معنی پیدا می‌کنند و استفاده از آن‌ها با نوشتن نام شی، عملگر نقطه و نام متد امکان‌پذیر است):

![image](/img/unity_vector2_class_methods.png)

اطلاعات بیشتر: https://docs.unity3d.com/ScriptReference/Vector2.html

### `Vector3`

`Vector3` نوع داده‌ای است که امکان ذخیره‌ی مختصات سه‌بعدی را دارد. این نوع داده در واقع از سه پراپرتی float تشکیل شده که `x` طول نقطه‌ی مختصات، `y` عرض نقطه‌ی مختصات و `z` ارتفاع نقطه‌ی مختصات را در خود ذخیره می‌کند. این سه پراپرتی توسط متد سازنده مقداردهی می‌شوند؛ به عنوان مثال:

![image](/img/unity_vector3_class.png)

:::note نکته
امکان دسترسی (خواندن/نوشتن) به پراپرتی‌های `y` ،`x` و `z` از طریق dot operator نیز وجود دارد.
:::

از آن‌جایی که پراپرتی‌های position و localScale کامپوننت Transform از نوع داده‌ی `Vector3` هستند از آن در اسکریپت‌نویسی به وفور استفاده می‌شود.

اعضای مهم این کلاس عبارتند از:

* پراپرتی‌های استاتیک (این پراپرتی‌ها نیازی به وجود یک شی از نوع کلاس نداشته و استفاده از آن‌ها با نوشتن کلمه‌ی کلیدی `Vector3`، عملگر نقطه و نام پراپرتی امکان‌پذیر است):

![image](/img/unity_vector3_class_static_properties.png)

* پراپرتی‌ها (این پراپرتی‌ها تنها در صورت وجود یک شی معنی پیدا می‌کنند و استفاده از آن‌ها با نوشتن نام شی، عملگر نقطه و نام پراپرتی امکان‌پذیر است):

![image](/img/unity_vector3_properties.png)

* متدهای استاتیک (این متدها نیازی به وجود یک شی از نوع کلاس نداشته و استفاده از آن‌ها با نوشتن کلمه‌ی کلیدی `Vector3`، عملگر نقطه و نام متد امکان‌پذیر است):

![image](/img/unity_vector3_static_methods.png)

* متدها (این متدها تنها در صورت وجود یک شی معنی پیدا می‌کنند و استفاده از آن‌ها با نوشتن نام شی، عملگر نقطه و نام متد امکان‌پذیر است):

![image](/img/unity_vector3_methods.png)

اطلاعات بیشتر: https://docs.unity3d.com/ScriptReference/Vector3.html

## کلاس‌های اطلاع‌رسانی و محاسبه

به وسیله‌ی این کلاس‌ها می‌توان اطلاعاتی درباره‌ی بازی، مدت زمان اجرای آن، سخت‌افزار پلیر و… به دست آورد و یا محاسبات ریاضی انجام داد. از آن جایی که اعضایی که در این کلاس‌ها قرار دارند استاتیک هستند برای استفاده از این کلاس‌ها نیازی به ساخت شی از روی کلاس نیست.

### `Debug`

#### پنجره‌ی Console

در هنگام رخ دادن هرگونه خطا یا اتفاقی که نیاز به اخطار به توسعه‌دهنده باشد ادیتور یونیتی یک توضیح در قالب متن به توسعه‌دهنده اعلان می‌کند. این اعلان‌ها به صورت نوتیفیکیشن در پایین ادیتور یونیتی نمایش داده می‌شوند و سپس در پنجره‌ای به نام Console (واقع در منوی Window > General > Console) ذخیره شده که امکان مشاهده‌ی جزئیات بیشتر آن‌ها را فراهم می‌کند. اعلان‌های ذکر شده ممکن است در حین روند توسعه و یا هنگام اجرای بازی روی دهند.

![image](/img/unity_editor_console_errors.png)

امکان فیلترگذاری بر روی نمایش هرکدام از دسته‌ها با استفاده از دکمه‌های سمت راست نوار کنترل Console وجود دارد. در کنار هر دکمه تعداد اعلان‌های آن دسته نشان داده می‌شود.

سایر دکمه‌های نوار کنترل پنجره‌ی Console عبارتند از:

* Clear: اعلانات داده شده را پاک می‌کند.

* Collapse: در صورت فعال بودن، اعلان‌های تکراری را در یک اعلان خلاصه کرده و در کنارش تعداد آن اعلان را نمایش می‌دهد.

* Clear On Play: در صورت فعال بودن، با هر بار اجرای بازی اعلان‌های کنسول پاک می‌شوند.

* Error Pause: در صورت فعال بودن، با وقوع هر خطا در حین اجرای بازی، روند اجرا متوقف (pause) می‌شود.

اعلان‌های ادیتور به سه دسته تقیسم می‌شوند:

* خطا (Error): ایرادی حیاتی است که غالباً می‌تواند روند خروجی گرفتن از پروژه را با اختلال روبه‌رو کند.

* اخطار (Warning): مواردی که ممکن است باعث ایجاد مشکل شده و باید به اطلاع توسعه‌دهنده رسانده شود.

* پیام (Message): یک پیام ساده که معمولاً برای تست و خطایابی توسط توسعه‌دهنده به صورت دستی و به‌وسیله‌ی کد نمایش داده می‌شود.

برای وارد کردن اعلان به Console به صورت دستی و به وسیله‌ی کد از کلاس `Debug` استفاده می‌شود.

اعضای مهم این کلاس عبارتند از:

* متدهای استاتیک (این متدها نیازی به وجود یک شی از نوع کلاس نداشته و استفاده از آن‌ها با نوشتن کلمه‌ی کلیدی `Debug`، عملگر نقطه و نام متد امکان‌پذیر است):

![image](/img/unity_debug_class_static_methods.png)

*کلاس `object` کلاسی است که دارای متد `ToString` بوده و آن را به هر کلاسی که از آن ارث برده باشد ارائه می‌کند. این متد برای این کلاس‌ها override شده و در نهایت یک رشته به درون متدهای جدول بالا پاس می‌شود.*

اطلاعات بیشتر: https://docs.unity3d.com/ScriptReference/Debug.html

### `Time`

کلاس `Time` دارای تعدادی پراپرتی استاتیک است که پراپرتی‌های «فقط خواندنی» اطلاعاتی را درباره‌ی زمان در اختیار توسعه دهنده قرار داده و پراپرتی‌های «خواندنی/نوشتنی» امکان مدیریت تنظیمات مربوط به زمان را فراهم می‌کنند.

اعضای مهم این کلاس عبارتند از:

* پراپرتی‌های استاتیک (این پراپرتی‌ها نیازی به وجود یک شی از نوع کلاس نداشته و استفاده از آن‌ها با نوشتن کلمه‌ی کلیدی `Time`، عملگر نقطه و نام پراپرتی امکان‌پذیر است):

![image](/img/unity_time_class_static_properties.png)

از پراپرتی `Time.deltaTime` برای یکسان‌سازی سرعت تغییرات در دستگاه‌های مختلف استفاده می‌شود. برای مثال فرض کنید که در یک متد `Update` دستوری برای جابجایی یک گیم آبجکت به اندازه‌ی `speed` وجود دارد. اگر این بازی در دو دستگاه اجرا شود که دستگاه اولی بازی را با سرعت 60 فریم در ثانیه و دستگاه دومی به علت ضعیف‌تر بودن پردازنده بازی را با سرعت 30 فریم در ثانیه اجرا کند این دستور در دستگاه اول 60 بار در ثانیه اجرا شده است؛ در حالی که دستگاه دوم همان دستور را تنها 30 بار در ثانیه اجرا می‌کند. بدیهی است که در دستگاه اول گیم آبجکت مسافتی دوبرابر مسافت خود در دستگاه دوم را در یک ثانیه طی می‌کند. برای جلوگیری از این اتفاق کافی است که مقدار `speed` در پراپرتی `Time.deltaTime` ضرب شود. زیرا در دستگاه سریع‌تر مدت زمان نمایش فریم کوتاه بوده و ضرب `speed` در این عدد کوچک مسافت طی شده را کاهش می‌دهد؛ در دستگاه کندتر نیز که مدت زمان نمایش فریم طولانی‌تر است ضرب `speed` در این عدد موجب جابجایی مسافت بیشتری در یک فریم نسبت به دستگاه سریع‌تر می‌شود.

پراپرتی `Time.timeScale` نیز سرعت گذر زمان در جهان بازی را تعیین می‌کند. در صورتی که این پراپرتی برابر 1 باشد بازی با سرعت عادی اجرا شده و اگر این مقدار به 0 برسد گذر زمان در جهان بازی متوقف می‌شود. با تغییر این مقدار به عددی بین 0 و 1 می‌توان به درجات مختلفی از اسلوموشن در جهان بازی دست یافت.

اطلاعات بیشتر: https://docs.unity3d.com/ScriptReference/Time.html

### `Mathf`

از این کلاس برای محاسبات ریاضی استفاده می‌شود.

اعضای مهم این کلاس عبارتند از:

* پراپرتی‌های استاتیک (این پراپرتی‌ها نیازی به وجود یک شی از نوع کلاس نداشته و استفاده از آن‌ها با نوشتن کلمه‌ی کلیدی `Mathf`، عملگر نقطه و نام پراپرتی امکان‌پذیر است):

![image](/img/unity_mathf_class_static_properties.png)

* متدهای استاتیک (این متدها نیازی به وجود یک شی از نوع کلاس نداشته و استفاده از آن‌ها با نوشتن کلمه‌ی کلیدی `Mathf`، عملگر نقطه و نام متد امکان‌پذیر است):

![image](/img/unity_mathf_class_static_methods.png)

اطلاعات بیشتر: https://docs.unity3d.com/ScriptReference/Mathf.html

### `Input`

دستگاه‌های ورودی سخت‌افزارهایی هستند که با استفاده از آن‌ها می‌توان اطلاعاتی را به بازی وارد نمود؛ سخت‌افزارهایی مانند کیبورد، ماوس، کنترلر، صفحه‌نمایش لمسی و…

دریافت وضعیت هرکدام از دستگاه‌های ورودی به منظور پیاده‌سازی عکس‌العمل مناسب در بازی از طریق کلاس `Input` صورت می‌پذیرد. این کلاس دارای متدهای استاتیکی است که می‌توانند از وضعیت یک ورودی خاص مربوط به دستگاه‌های ورودی (مثل فشرده شدن کلیک ماوس، فشرده شدن یک دکمه‌ی خاص کیبورد و…) باخبر شده و نتیجه را در قالب خروجی متد (true یا false) بازگردانی کنند. به عنوان مثال متد `Input.GetMouseButton(0)` وضعیت کلیک چپ ماوس را در قالب bool بازگردانی می‌کند؛ مقدار خروجی این متد در حالت عادی برابر `false` و هنگام نگه داشتن کلیک چپ ماوس برابر با `true` می‌شود.

به همین وسیله می‌توان به عملی که پلیر انجام داده است پی برد و متناسب با آن رفتار معینی را پیاده‌سازی نمود. به عنوان مثال با قرار دادن این متد به عنوان شرط یک بلوک `if` (در متد `Update` یک اسکریپت) می‌توان کاری کرد که کدهای درون بلوک این `if` در زمان نگه داشته شدن کلیک ماوس اجرا شوند.

#### تعریف ورودی‌های دلخواه و کار با Input Manager

علاوه بر ورودی‌هایی که به صورت مستقیم به وسیله‌ی دستگاه‌های ورودی ایجاد می‌شوند، امکان تعریف ورودی‌های پیچیده‌تر دلخواه نیز وجود دارد. به این منظور از ابزاری به نام Input Manager استفاده می‌شود. با رفتن به منوی Edit > Project Settings > Input می‌توان این ابزار را در پنجره‌ی Inspector مشاهده کرد. در این ابزار لیستی به نام Axes دیده می‌شود که در آن ورودی‌های تعریف شده برای پروژه قرار دارند. در این لیست تعدادی ورودی از قبل ساخته شده توسط یونیتی وجود دارد که می‌توان از آن‌ها استفاده نمود و یا ورودی‌های جدیدی تعریف کرد. این ورودی‌ها پس از تعریف، با نام یکتای خود (که از نوع string است) در کدنویسی استفاده می‌شوند.

ما امکان تعریف دو نوع ورودی دلخواه در یونیتی را داریم: Axis و Button

1. ورودی Axis (محوری):

    مقداری از نوع float است که می‌تواند بین -1 و +1 باشد. این ورودی دو دکمه‌ی سخت‌افزاری را به عنوان دکمه‌های مثبت و منفی در نظر می‌گیرد. در حالت عادی که هیچ دکمه‌ای در حال فشرده شدن نیست مقدار ورودی برابر 0 (خنثی) است. هنگامی که دکمه‌ی مثبت فشار داده شود مقدار ورودی افزایش یافته تا در نهایت به ماکسیمم خود (+1) برسد و هنگامی که دکمه‌ی منفی در حال فشرده شدن است مقدار ورودی کاهش یافته تا در نهایت به می‌نیمم خود (-1) برسد.

    از ورودی محوری بیشتر در مواردی استفاده می‌شود که قصد جابجایی و چرخش به وسیله‌ی آن را داشته باشیم.

    برای مثال در اکثر مواقع برای جابجایی کاراکتر، به درون متد جابجایی یک ورودی محوری ارسال می‌شود (که در `speed` ضرب می‌شود). دکمه‌ی مثبت و منفی این ورودی کلیدهای جهت‌نمای راست و چپ صفحه‌کلید هستند که با فشردن دکمه‌ی مثبت سرعت پلیر مثبت شده و رو به جلو حرکت می‌کند و با فشردن دکمه‌ی منفی سرعت پلیر منفی شده و رو به عقب حرکت می‌کند.

![image](/img/game_controller_axis.png)

*هر آنالوگ کنترلر شامل دو ورودی Axis است که توامان موجب حرکت در آنالوگ سمت چپ و چرخش در آنالوگ سمت راست می‌شوند.*

:::note تمرین
برای آشنایی بیشتر با نحوه‌ی کار با Input Manager قصد داریم که ورودی محوری جدیدی به نام Test Axis ایجاد کنیم. می‌خواهیم که دکمه‌ی مثبت این ورودی کلیک راست ماوس و دکمه‌ی منفی آن کلیک چپ ماوس باشد.

برای این کار ابتدا لیست Axes ابزار Input Manager را باز کرده و مقدار Size آن را یکی زیاد کرده تا عضو جدیدی در انتهای لیست ظاهر شود. سپس عضو جدید را باز کرده و در بخش Name عبارت Test Axis را بنویسید. در بخش دکمه‌ی منفی (Negative Button) عبارت mouse 0 و در بخش دکمه‌ی مثبت (Positive Button) عبارت mouse 1 را بنویسید (می‌توانید لیست کامل نام دکمه‌های سخت‌افزاری را در https://docs.unity3d.com/ScriptReference/KeyCode.html مشاهده کنید).

![image](/img/input_manager_test_axis.png)

حال با استفاده از کد `Input.GetAxis(“Test Axis")` می‌توان به مقدار ورودی دست یافت. صحت عملکرد ورودی را با استفاده از متد `Debug.Log` در متد `Update` بررسی کنید.
:::

2. ورودی Button (دکمه‌ای):

    نحوه‌ی تعریف این نوع ورودی مشابه تعریف ورودی محوری است. این ورودی از نوع bool بوده که مقدارش در حالت عادی false است و با فشرده شدن دکمه‌ی مثبت (Positive Button) تعریف شده برای ورودی true می‌شود.

اعضای مهم این کلاس عبارتند از:

* پراپرتی‌های استاتیک (این پراپرتی‌ها نیازی به وجود یک شی از نوع کلاس نداشته و استفاده از آن‌ها با نوشتن کلمه‌ی کلیدی `Input`، عملگر نقطه و نام پراپرتی امکان‌پذیر است):

![image](/img/unity_input_class_static_properties.png)

* متدهای استاتیک (این متدها نیازی به وجود یک شی از نوع کلاس نداشته و استفاده از آن‌ها با نوشتن کلمه‌ی کلیدی `Input`، عملگر نقطه و نام متد امکان‌پذیر است):

![image](/img/unity_input_class_static_methods.png)

*اگر button=0 کلیک چپ ماوس، اگر button=1 کلیک راست ماوس و اگر button=2 کلیک وسط ماوس*

اطلاعات بیشتر: https://docs.unity3d.com/ScriptReference/Input.html

## کلاس `GameObject`

کلاس `GameObject` کلاسی است که یک گیم آبجکت می‌تواند درون شی‌ای از نوع آن قرار بگیرد. در صورتی که قصد داشته باشیم با استفاده از کد بر روی یک گیم آبجکت خاص مدیریت داشته باشیم آن را درون شی‌ای از نوع `GameObject` قرار می‌دهیم. به این منظور ابتدا فیلدی از این نوع داده تعریف کرده و سپس آن را با گیم آبجکت موردنظر مقداردهی می‌کنیم. پس از این کار می‌توان با استفاده از dot operator عملیات لازم را بر روی آن انجام داد.

مقداردهی و دسترسی به اشیای `GameObject` به دو روش صورت می‌پذیرد:

1. استفاده از متدهای استاتیک کلاس `GameObject` که امکان جستجوی گیم آبجکت بر اساس نام، تگ و… در صحنه را فراهم کرده و خروجی آن‌ها از نوع `GameObject` و شامل نتیجه(های) جستجو است.

2. سریالایز کردن فیلد و مقداردهی به صورت دستی در Inspector

اعضای مهم این کلاس عبارتند از:

* پراپرتی‌ها (این پراپرتی‌ها تنها در صورت وجود یک شی معنی پیدا می‌کنند و استفاده از آن‌ها با نوشتن نام شی، عملگر نقطه و نام پراپرتی امکان‌پذیر است):

![image](/img/unity_gameobject_class_properties.png)

* متدهای استاتیک (این متدها نیازی به وجود یک شی از نوع کلاس نداشته و استفاده از آن‌ها با نوشتن کلمه‌ی کلیدی `GameObject`، عملگر نقطه و نام متد امکان‌پذیر است):

![image](/img/unity_gameobject_class_static_methods.png)

* متدها (این متدها تنها در صورت وجود یک شی معنی پیدا می‌کنند و استفاده از آن‌ها با نوشتن نام شی، عملگر نقطه و نام متد امکان‌پذیر است):

![image](/img/unity_gameobject_class_methods.png)

اطلاعات بیشتر: https://docs.unity3d.com/ScriptReference/GameObject.html

## کلاس‌های کامپوننت‌ها

می‌دانیم که کامپوننت‌های اختصاصی ساخته شده توسط توسعه‌دهنده در واقع کلاس‌هایی هستند که به صورت دستی توسط وی نوشته شده‌اند. علاوه بر این کلاس‌ها، به ازای هر نوع کامپوننت بومی که در ادیتور یونیتی موجود است کلاسی همنام آن در فضای نام `UnityEngine` وجود دارد.

به وسیله‌ی این قابلیت می‌توان در صورتی که نیاز به کنترل یک کامپوننت از طریق کد داشته باشیم در اسکریپت‌ها فیلدی از نوع داده‌ی کامپوننت تعریف کرده و شی کامپوننت‌های متناسب با نوع داده را در آن قرار داد. سپس کامپوننت را در قالب کد معرفی کرده و به اعضای آن دسترسی پیدا کرد. این اعضا می‌توانند فیلدها و متدهایی باشند که توسط یونیتی و یا توسعه‌دهنده نوشته شده است.

به عنوان مثال اگر یک گیم‌آبجکت دارای کامپوننت (که گفته شد معادل شی است) RigidBody2D باشد می‌توان فیلدی از نوع `RigidBody2D` تعریف و کامپوننت را به آن نسبت داد. سپس با استفاده از dot operator به متدهای از پیش طراحی شده و سایر اعضای آن دسترسی پیدا کرد.

مقداردهی و دسترسی به اشیای کامپوننت‌ها به دو روش صورت می‌پذیرد:

1. صدا زدن متد `GetComponent` بر روی گیم آبجکت حاوی کامپوننت موردنظر

2. سریالایز کردن فیلد و مقداردهی آن به صورت دستی در Inspector با گیم آبجکت حاوی کامپوننت موردنظر

### کلاس `Component`

کلاس‌های کامپوننت‌ها همگی از کلاسی به نام `Component` ارث‌بری می‌کنند. سطح دسترسی اعضای این کلاس به صورتی است که تمامی آن‌ها را به کلاس‌های فرزند ارث می‌دهد؛ بنابراین اعضای این کلاس در تمامی کلاس‌های کامپوننت‌ها نیز قابل دسترسی و استفاده هستند.

اعضای مهم این کلاس عبارتند از:

* پراپرتی‌ها (این پراپرتی‌ها تنها در صورت وجود یک شی معنی پیدا می‌کنند و استفاده از آن‌ها با نوشتن نام شی، عملگر نقطه و نام پراپرتی امکان‌پذیر است):

![image](/img/unity_component_class_properties.png)

* متدهای استاتیک (این متدها نیازی به وجود یک شی از نوع کلاس نداشته و استفاده از آن‌ها تنها با نوشتن نام متد امکان‌پذیر است):

![image](/img/unity_component_class_static_methods.png)

اطلاعات بیشتر: https://docs.unity3d.com/ScriptReference/Component.html

### `Transform`

در شی ساخته شده از روی این کلاس می‌توان یک کامپوننت Transform قرار داد.

از آنجایی که تمام گیم آبجکت‌ها دارای کامپوننت Transform هستند و Hierarchy از این کامپوننت برای تعیین سلسله‌مراتب گیم آبجکت‌ها استفاده می‌کند می‌توان مجازاً از این کامپوننت به عنوان گیم آبجکت استفاده کرد.

این کامپوننت حاوی اطلاعات مکانی گیم آبجکت است و به همین علت با استفاده از متدهای کلاس آن می‌توان نسبت به جابجایی، چرخش و… گیم آبجکت اقدام نمود.

اعضای مهم این کلاس عبارتند از:

* پراپرتی‌ها (این پراپرتی‌ها تنها در صورت وجود یک شی معنی پیدا می‌کنند و استفاده از آن‌ها با نوشتن نام شی، عملگر نقطه و نام پراپرتی امکان‌پذیر است):

![image](/img/unity_transform_class_properties.png)

* متدها (این متدها تنها در صورت وجود یک شی معنی پیدا می‌کنند و استفاده از آن‌ها با نوشتن نام شی، عملگر نقطه و نام متد امکان‌پذیر است):

![image](/img/unity_transform_class_methods.png)

*توصیه می‌شود که مقادیر وارد شده در متدهای `Translate` و `Rotate` در مقدار `Time.deltaTime` ضرب شوند.*

اطلاعات بیشتر: https://docs.unity3d.com/ScriptReference/Transform.html

### `Rigidbody2D`

در شی ساخته شده از روی این کلاس می‌توان یک کامپوننت Rigidbody 2D قرار داد.

این کامپوننت قوانین فیزیک دوبعدی را بر روی گیم آبجکت اعمال کرده و به همین علت متدهای کلاس آن مربوط به پیاده‌سازی تغییرات فیزیکی بر روی گیم آبجکت است.

اعضای مهم این کلاس عبارتند از:

* متدها (این متدها تنها در صورت وجود یک شی معنی پیدا می‌کنند و استفاده از آن‌ها با نوشتن نام شی، عملگر نقطه و نام متد امکان‌پذیر است):

![image](/img/unity_rigidbody2d_class_methods.png)

اطلاعات بیشتر: https://docs.unity3d.com/ScriptReference/Rigidbody2D.html

### `Animator`

در شی ساخته شده از روی این کلاس می‌توان یک کامپوننت Animator قرار داد.

این کامپوننت مدیریت انیمیشن‌های گیم آبجکت را بر عهده دارد و به همین علت متدهای کلاس آن مربوط به کار با انیماتور است.

اعضای مهم این کلاس عبارتند از:

* متدها (این متدها تنها در صورت وجود یک شی معنی پیدا می‌کنند و استفاده از آن‌ها با نوشتن نام شی، عملگر نقطه و نام متد امکان‌پذیر است):

![image](/img/unity_animator_class_methods.png)

اطلاعات بیشتر: https://docs.unity3d.com/ScriptReference/AudioSource.html

### `AudioSource`

در شی ساخته شده از روی این کلاس می‌توان یک کامپوننت Audio Source قرار داد.

این کامپوننت وظیفه‌ی پخش صوت را بر عهده دارد و به همین علت متدهای کلاس آن مربوط به کنترل صدا است.

اعضای مهم این کلاس عبارتند از:

* پراپرتی‌ها (این پراپرتی‌ها تنها در صورت وجود یک شی معنی پیدا می‌کنند و استفاده از آن‌ها با نوشتن نام شی، عملگر نقطه و نام پراپرتی امکان‌پذیر است):

![image](/img/unity_audiosource_class_properties.png)

متدهای استاتیک (این متدها نیازی به وجود یک شی از نوع کلاس نداشته و استفاده از آن‌ها با نوشتن کلمه‌ی کلیدی `AudioSource`، عملگر نقطه و نام متد امکان‌پذیر است):

![image](/img/unity_audiosource_class_static_methods.png)

*1. در صورتی که مکان خاصی برای پخش صدا مدنظرتان نیست و یا خروجی سیگنال صدا (به علت دوبعدی بودن) مستقل از مکان است می‌توانید مقدار `transform.position` را به عنوان پارامتر `position` استفاده کنید.*

*2. مقدار ماکسیمم برای شدت صدا 1.0 و مقدار می‌نیمم (میوت) برای آن 0 است.*

* متدها (این متدها تنها در صورت وجود یک شی معنی پیدا می‌کنند و استفاده از آن‌ها با نوشتن نام شی، عملگر نقطه و نام متد امکان‌پذیر است):

![image](/img/unity_audiosource_class_methods.png)

اطلاعات بیشتر: https://docs.unity3d.com/ScriptReference/AudioSource.html